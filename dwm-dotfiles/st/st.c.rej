--- st.c
+++ st.c
@@ -660,39 +728,34 @@ char *
 getsel(void)
 {
 	char *str, *ptr;
-	int y, bufsize, lastx, linelen;
-	const Glyph *gp, *last;
+	int y, lastx, linelen;
+	const Glyph *gp, *lgp;
 
-	if (sel.ob.x == -1)
+	if (sel.ob.x == -1 || sel.alt != IS_SET(MODE_ALTSCREEN))
 		return NULL;
 
-	bufsize = (term.col+1) * (sel.ne.y-sel.nb.y+1) * UTF_SIZ;
-	ptr = str = xmalloc(bufsize);
+	str = xmalloc((term.col + 1) * (sel.ne.y - sel.nb.y + 1) * UTF_SIZ);
+	ptr = str;
 
 	/* append every set & selected glyph to the selection */
 	for (y = sel.nb.y; y <= sel.ne.y; y++) {
-		if ((linelen = tlinelen(y)) == 0) {
+		Line line = TLINE(y);
+
+		if ((linelen = tlinelen(line)) == 0) {
 			*ptr++ = '\n';
 			continue;
 		}
 
 		if (sel.type == SEL_RECTANGULAR) {
-			gp = &TLINE(y)[sel.nb.x];
+			gp = &line[sel.nb.x];
 			lastx = sel.ne.x;
 		} else {
-			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
+			gp = &line[sel.nb.y == y ? sel.nb.x : 0];
 			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
 		}
-		last = &TLINE(y)[MIN(lastx, linelen-1)];
-		while (last >= gp && last->u == ' ')
-			--last;
+		lgp = &line[MIN(lastx, linelen-1)];
 
-		for ( ; gp <= last; ++gp) {
-			if (gp->mode & ATTR_WDUMMY)
-				continue;
-
-			ptr += utf8encode(gp->u, ptr);
-		}
+		ptr = tgetglyphs(ptr, gp, lgp);
 
 		/*
 		 * Copy and pasting of line endings is inconsistent
@@ -1091,162 +1160,261 @@ tcursor(int mode)
 	}
 }
 
+void
+tresetcursor(void)
+{
+	term.c = (TCursor){ { .mode = ATTR_NULL, .fg = defaultfg, .bg = defaultbg },
+	                    .x = 0, .y = 0, .state = CURSOR_DEFAULT };
+}
+
 void
 treset(void)
 {
 	uint i;
+    int x, y;
 
-	term.c = (TCursor){{
-		.mode = ATTR_NULL,
-		.fg = defaultfg,
-		.bg = defaultbg
-	}, .x = 0, .y = 0, .state = CURSOR_DEFAULT};
+	tresetcursor();
 
 	memset(term.tabs, 0, term.col * sizeof(*term.tabs));
 	for (i = tabspaces; i < term.col; i += tabspaces)
 		term.tabs[i] = 1;
 	term.top = 0;
+	term.histf = 0;
+	term.scr = 0;
 	term.bot = term.row - 1;
 	term.mode = MODE_WRAP|MODE_UTF8;
 	memset(term.trantbl, CS_USA, sizeof(term.trantbl));
 	term.charset = 0;
 
+    selremove();
 	for (i = 0; i < 2; i++) {
-		tmoveto(0, 0);
-		tcursor(CURSOR_SAVE);
-		tclearregion(0, 0, term.col-1, term.row-1);
-		tswapscreen();
+        tcursor(CURSOR_SAVE); /* reset saved cursor */
+        for (y = 0; y < term.row; y++)
+            for (x = 0; x < term.col; x++)
+                tclearglyph(&term.line[y][x], 0);
+        tswapscreen();
 	}
+    tfulldirt();
 }
 
 void
 tnew(int col, int row)
 {
-	term = (Term){ .c = { .attr = { .fg = defaultfg, .bg = defaultbg } } };
-	tresize(col, row);
-	treset();
+    int i, j;
+
+    for (i = 0; i < 2; i++) {
+        term.line = xmalloc(row * sizeof(Line));
+        for (j = 0; j < row; j++)
+            term.line[j] = xmalloc(col * sizeof(Glyph));
+        term.col = col, term.row = row;
+        tswapscreen();
+    }
+    term.dirty = xmalloc(row * sizeof(*term.dirty));
+    term.tabs = xmalloc(col * sizeof(*term.tabs));
+    for (i = 0; i < HISTSIZE; i++)
+        term.hist[i] = xmalloc(col * sizeof(Glyph));
+    treset();
 }
 
+/* handle it with care */
 void
 tswapscreen(void)
 {
-	Line *tmp = term.line;
+	static Line *altline;
+	static int altcol, altrow;
+	Line *tmpline = term.line;
+	int tmpcol = term.col, tmprow = term.row;
 
-	term.line = term.alt;
-	term.alt = tmp;
+	term.line = altline;
+	term.col = altcol, term.row = altrow;
+	altline = tmpline;
+	altcol = tmpcol, altrow = tmprow;
 	term.mode ^= MODE_ALTSCREEN;
-	tfulldirt();
 }
 
 void
-kscrolldown(const Arg* a)
+tloaddefscreen(int clear, int loadcursor)
 {
-	int n = a->i;
+	int col, row, alt = IS_SET(MODE_ALTSCREEN);
 
-	if (n < 0)
-		n = term.row + n;
+	if (alt) {
+		if (clear)
+			tclearregion(0, 0, term.col-1, term.row-1, 1);
+		col = term.col, row = term.row;
+		tswapscreen();
+	}
+	if (loadcursor)
+		tcursor(CURSOR_LOAD);
+	if (alt)
+		tresizedef(col, row);
+}
 
-	if (n > term.scr)
-		n = term.scr;
+void
+tloadaltscreen(int clear, int savecursor)
+{
+	int col, row, def = !IS_SET(MODE_ALTSCREEN);
 
-	if (term.scr > 0) {
-		term.scr -= n;
-		selscroll(0, -n);
-		tfulldirt();
+	if (savecursor)
+		tcursor(CURSOR_SAVE);
+	if (def) {
+		col = term.col, row = term.row;
+		tswapscreen();
+		term.scr = 0;
+		tresizealt(col, row);
 	}
+	if (clear)
+		tclearregion(0, 0, term.col-1, term.row-1, 1);
 }
 
+int
+tisaltscreen(void)
+{
+	return IS_SET(MODE_ALTSCREEN);
+}
+
+
 void
-kscrollup(const Arg* a)
+kscrolldown(const Arg* a)
 {
-	int n = a->i;
+    int n = a->i;
 
-	if (n < 0)
-		n = term.row + n;
+    if (!term.scr || IS_SET(MODE_ALTSCREEN))
+        return;
 
-	if (term.scr <= HISTSIZE-n) {
-		term.scr += n;
-		selscroll(0, n);
-		tfulldirt();
-	}
+    if (n < 0)
+        n = MAX(term.row / -n, 1);
+
+    if (n <= term.scr) {
+        term.scr -= n;
+    } else {
+        n = term.scr;
+        term.scr = 0;
+    }
+	if (sel.ob.x != -1 && !sel.alt)
+		selmove(-n); /* negate change in term.scr */
+	tfulldirt();
 }
 
+
+
 void
-tscrolldown(int orig, int n, int copyhist)
+kscrollup(const Arg* a)
 {
-	int i;
-	Line temp;
+    int n = a->i;
 
-	LIMIT(n, 0, term.bot-orig+1);
+    if (!term.histf || IS_SET(MODE_ALTSCREEN))
+        return;
 
-	if (copyhist) {
-		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
-		temp = term.hist[term.histi];
-		term.hist[term.histi] = term.line[term.bot];
-		term.line[term.bot] = temp;
-	}
+    if (n < 0)
+        n = MAX(term.row / -n, 1);
 
-	tsetdirt(orig, term.bot-n);
-	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
+    if (term.scr + n <= term.histf) {
+        term.scr += n;
+    } else {
+        n = term.histf - term.scr;
+        term.scr = term.histf;
+    }
 
-	for (i = term.bot; i >= orig+n; i--) {
-		temp = term.line[i];
-		term.line[i] = term.line[i-n];
-		term.line[i-n] = temp;
-	}
+    if (sel.ob.x != -1 && !sel.alt)
+        selmove(n); /* negate change in term.scr */
+    tfulldirt();
 
-	if (term.scr == 0)
-		selscroll(orig, n);
 }
 
 void
-tscrollup(int orig, int n, int copyhist)
+tscrolldown(int top, int n)
 {
-	int i;
-	Line temp;
+    int i, bot = term.bot;
+    Line temp;
 
-	LIMIT(n, 0, term.bot-orig+1);
+    if (n <= 0)
+        return;
+    n = MIN(n, bot-top+1);
 
-	if (copyhist) {
-		term.histi = (term.histi + 1) % HISTSIZE;
-		temp = term.hist[term.histi];
-		term.hist[term.histi] = term.line[orig];
-		term.line[orig] = temp;
-	}
+    tsetdirt(top, bot-n);
+    tclearregion(0, bot-n+1, term.col-1, bot, 1);
 
-	if (term.scr > 0 && term.scr < HISTSIZE)
-		term.scr = MIN(term.scr + n, HISTSIZE-1);
+    for (i = bot; i >= top+n; i--) {
+        temp = term.line[i];
+        term.line[i] = term.line[i-n];
+        term.line[i-n] = temp;
+    }
 
-	tclearregion(0, orig, term.col-1, orig+n-1);
-	tsetdirt(orig+n, term.bot);
+    if (sel.ob.x != -1 && sel.alt == IS_SET(MODE_ALTSCREEN))
+        selscroll(top, bot, n);
+}
 
-	for (i = orig; i <= term.bot-n; i++) {
-		temp = term.line[i];
-		term.line[i] = term.line[i+n];
-		term.line[i+n] = temp;
-	}
+void
+tscrollup(int top, int bot, int n, int mode)
+{
+    int i, j, s;
+    int alt = IS_SET(MODE_ALTSCREEN);
+    int savehist = !alt && top == 0 && mode != SCROLL_NOSAVEHIST;
+    Line temp;
+
+    if (n <= 0)
+        return;
+    n = MIN(n, bot-top+1);
 
-	if (term.scr == 0)
-		selscroll(orig, -n);
+    if (savehist) {
+        for (i = 0; i < n; i++) {
+            term.histi = (term.histi + 1) % HISTSIZE;
+            temp = term.hist[term.histi];
+            for (j = 0; j < term.col; j++)
+                tclearglyph(&temp[j], 1);
+            term.hist[term.histi] = term.line[i];
+            term.line[i] = temp;
+        }
+        term.histf = MIN(term.histf + n, HISTSIZE);
+        s = n;
+        if (term.scr) {
+            j = term.scr;
+            term.scr = MIN(j + n, HISTSIZE);
+            s = j + n - term.scr;
+        }
+        if (mode != SCROLL_RESIZE)
+            tfulldirt();
+    } else {
+        tclearregion(0, top, term.col-1, top+n-1, 1);
+        tsetdirt(top+n, bot);
+    }
+
+    for (i = top; i <= bot-n; i++) {
+        temp = term.line[i];
+        term.line[i] = term.line[i+n];
+        term.line[i+n] = temp;
+    }
+
+    if (sel.ob.x != -1 && sel.alt == alt) {
+        if (!savehist) {
+            selscroll(top, bot, -n);
+        } else if (s > 0) {
+            selmove(-s);
+            if (-term.scr + sel.nb.y < -term.histf)
+                selremove();
+        }
+    }
 }
 
 void
-selscroll(int orig, int n)
+selmove(int n)
+ {
+	sel.ob.y += n, sel.nb.y += n;
+	sel.oe.y += n, sel.ne.y += n;
+}
+
+void
+selscroll(int top, int bot, int n)
 {
-	if (sel.ob.x == -1 || sel.alt != IS_SET(MODE_ALTSCREEN))
-		return;
+    /* turn absolute coordinates into relative */
+    top += term.scr, bot += term.scr;
 
-	if (BETWEEN(sel.nb.y, orig, term.bot) != BETWEEN(sel.ne.y, orig, term.bot)) {
-		selclear();
-	} else if (BETWEEN(sel.nb.y, orig, term.bot)) {
-		sel.ob.y += n;
-		sel.oe.y += n;
-		if (sel.ob.y < term.top || sel.ob.y > term.bot ||
-		    sel.oe.y < term.top || sel.oe.y > term.bot) {
-			selclear();
-		} else {
-			selnormalize();
-		}
+    if (BETWEEN(sel.nb.y, top, bot) != BETWEEN(sel.ne.y, top, bot)) {
+        selclear();
+    } else if (BETWEEN(sel.nb.y, top, bot)) {
+        selmove(n);
+        if (sel.nb.y < top || sel.ne.y > bot)
+            selclear();
 	}
 }
 
@@ -1320,115 +1488,126 @@ tmoveto(int x, int y)
 void
 tsetchar(Rune u, const Glyph *attr, int x, int y)
 {
-	static const char *vt100_0[62] = { /* 0x41 - 0x7e */
-		"↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
-		0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
-		0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
-		0, 0, 0, 0, 0, 0, 0, " ", /* X - _ */
-		"◆", "▒", "␉", "␌", "␍", "␊", "°", "±", /* ` - g */
-		"␤", "␋", "┘", "┐", "┌", "└", "┼", "⎺", /* h - o */
-		"⎻", "─", "⎼", "⎽", "├", "┤", "┴", "┬", /* p - w */
-		"│", "≤", "≥", "π", "≠", "£", "·", /* x - ~ */
-	};
+    static const char *vt100_0[62] = { /* 0x41 - 0x7e */
+        "↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
+        0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
+        0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
+        0, 0, 0, 0, 0, 0, 0, " ", /* X - _ */
+        "◆", "▒", "␉", "␌", "␍", "␊", "°", "±", /* ` - g */
+        "␤", "␋", "┘", "┐", "┌", "└", "┼", "⎺", /* h - o */
+        "⎻", "─", "⎼", "⎽", "├", "┤", "┴", "┬", /* p - w */
+        "│", "≤", "≥", "π", "≠", "£", "·", /* x - ~ */
+    };
 
-	/*
-	 * The table is proudly stolen from rxvt.
-	 */
-	if (term.trantbl[term.charset] == CS_GRAPHIC0 &&
-	   BETWEEN(u, 0x41, 0x7e) && vt100_0[u - 0x41])
-		utf8decode(vt100_0[u - 0x41], &u, UTF_SIZ);
-
-	if (term.line[y][x].mode & ATTR_WIDE) {
-		if (x+1 < term.col) {
-			term.line[y][x+1].u = ' ';
-			term.line[y][x+1].mode &= ~ATTR_WDUMMY;
-		}
-	} else if (term.line[y][x].mode & ATTR_WDUMMY) {
-		term.line[y][x-1].u = ' ';
-		term.line[y][x-1].mode &= ~ATTR_WIDE;
-	}
+    /*
+     * The table is proudly stolen from rxvt.
+     */
+    if (term.trantbl[term.charset] == CS_GRAPHIC0 &&
+            BETWEEN(u, 0x41, 0x7e) && vt100_0[u - 0x41])
+        utf8decode(vt100_0[u - 0x41], &u, UTF_SIZ);
+
+    if (term.line[y][x].mode & ATTR_WIDE) {
+        if (x+1 < term.col) {
+            term.line[y][x+1].u = ' ';
+            term.line[y][x+1].mode &= ~ATTR_WDUMMY;
+        }
+    } else if (term.line[y][x].mode & ATTR_WDUMMY) {
+        term.line[y][x-1].u = ' ';
+        term.line[y][x-1].mode &= ~ATTR_WIDE;
+    }
 
-	term.dirty[y] = 1;
-	term.line[y][x] = *attr;
-	term.line[y][x].u = u;
+    term.dirty[y] = 1;
+    term.line[y][x] = *attr;
+    term.line[y][x].u = u;
+    term.line[y][x].mode |= ATTR_SET;
 }
 
+
+
 void
-tclearregion(int x1, int y1, int x2, int y2)
+tclearglyph(Glyph *gp, int usecurattr)
 {
-	int x, y, temp;
-	Glyph *gp;
+	if (usecurattr) {
+		gp->fg = term.c.attr.fg;
+		gp->bg = term.c.attr.bg;
+	} else {
+		gp->fg = defaultfg;
+		gp->bg = defaultbg;
+	}
+	gp->mode = ATTR_NULL;
+	gp->u = ' ';
+}
 
-	if (x1 > x2)
-		temp = x1, x1 = x2, x2 = temp;
-	if (y1 > y2)
-		temp = y1, y1 = y2, y2 = temp;
 
-	LIMIT(x1, 0, term.col-1);
-	LIMIT(x2, 0, term.col-1);
-	LIMIT(y1, 0, term.row-1);
-	LIMIT(y2, 0, term.row-1);
 
-	for (y = y1; y <= y2; y++) {
+void
+tclearregion(int x1, int y1, int x2, int y2, int usecurattr)
+{
+	int x, y;
+	/* regionselected() takes relative coordinates */
+	if (regionselected(x1+term.scr, y1+term.scr, x2+term.scr, y2+term.scr))
+		selremove();
+
+    for (y = y1; y <= y2; y++) {
 		term.dirty[y] = 1;
-		for (x = x1; x <= x2; x++) {
-			gp = &term.line[y][x];
-			if (selected(x, y))
-				selclear();
-			gp->fg = term.c.attr.fg;
-			gp->bg = term.c.attr.bg;
-			gp->mode = 0;
-			gp->u = ' ';
-		}
+		for (x = x1; x <= x2; x++)
+			tclearglyph(&term.line[y][x], usecurattr);
 	}
 }
 
 void
 tdeletechar(int n)
 {
-	int dst, src, size;
-	Glyph *line;
-
-	LIMIT(n, 0, term.col - term.c.x);
+    int src, dst, size;
+    Line line;
 
-	dst = term.c.x;
-	src = term.c.x + n;
-	size = term.col - src;
-	line = term.line[term.c.y];
+    if (n <= 0)
+        return;
 
-	memmove(&line[dst], &line[src], size * sizeof(Glyph));
-	tclearregion(term.col-n, term.c.y, term.col-1, term.c.y);
+    dst = term.c.x;
+    src = MIN(term.c.x + n, term.col);
+    size = term.col - src;
+    if (size > 0) {
+        /*
+         * otherwise src would point beyond the array
+         * https://stackoverflow.com/questions/29844298
+         */
+        line = term.line[term.c.y];
+        memmove(&line[dst], &line[src], size * sizeof(Glyph));
+    }
+    tclearregion(dst + size, term.c.y, term.col - 1, term.c.y, 1);
 }
 
 void
 tinsertblank(int n)
 {
-	int dst, src, size;
-	Glyph *line;
-
-	LIMIT(n, 0, term.col - term.c.x);
-
-	dst = term.c.x + n;
-	src = term.c.x;
-	size = term.col - dst;
-	line = term.line[term.c.y];
+    int src, dst, size;
+    Line line;
 
-	memmove(&line[dst], &line[src], size * sizeof(Glyph));
-	tclearregion(src, term.c.y, dst - 1, term.c.y);
+    if (n <= 0)
+        return;
+    dst = MIN(term.c.x + n, term.col);
+    src = term.c.x;
+    size = term.col - dst;
+    if (size > 0) { /* otherwise dst would point beyond the array */
+        line = term.line[term.c.y];
+        memmove(&line[dst], &line[src], size * sizeof(Glyph));
+    }
+    tclearregion(src, term.c.y, dst - 1, term.c.y, 1);
 }
 
 void
 tinsertblankline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrolldown(term.c.y, n, 0);
+		tscrolldown(term.c.y, n);
 }
 
 void
 tdeleteline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrollup(term.c.y, n, 0);
+		tscrollup(term.c.y, term.bot, n, SCROLL_NOSAVEHIST);
 }
 
 int32_t
@@ -1663,26 +1842,20 @@ tsetmode(int priv, int set, const int *args, int narg)
 				xsetmode(set, MODE_8BIT);
 				break;
 			case 1049: /* swap screen & set/restore cursor as xterm */
-				if (!allowaltscreen)
-					break;
-				tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
-				/* FALLTHROUGH */
 			case 47: /* swap screen */
-			case 1047:
+			case 1047: /*swap screen, clearing alternate screen */
 				if (!allowaltscreen)
 					break;
-				alt = IS_SET(MODE_ALTSCREEN);
-				if (alt) {
-					tclearregion(0, 0, term.col-1,
-							term.row-1);
-				}
-				if (set ^ alt) /* set is always 1 or 0 */
-					tswapscreen();
-				if (*args != 1049)
-					break;
+				if (set)
+					tloadaltscreen(*args == 1049, *args == 1049);
+				else
+					tloaddefscreen(*args == 1047, *args == 1049);
+				break;
 				/* FALLTHROUGH */
-			case 1048:
-				tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
+            case 1048:
+                if (!allowaltscreen)
+                    break;
+                tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
 				break;
 			case 2004: /* 2004: bracketed paste mode */
 				xsetmode(set, MODE_BRCKTPASTE);
@@ -1831,19 +2004,29 @@ csihandle(void)
 	case 'J': /* ED -- Clear screen */
 		switch (csiescseq.arg[0]) {
 		case 0: /* below */
-			tclearregion(term.c.x, term.c.y, term.col-1, term.c.y);
+			tclearregion(term.c.x, term.c.y, term.col-1, term.c.y, 1);
 			if (term.c.y < term.row-1) {
-				tclearregion(0, term.c.y+1, term.col-1,
-						term.row-1);
+				tclearregion(0, term.c.y+1, term.col-1, term.row-1, 1);
 			}
 			break;
 		case 1: /* above */
-			if (term.c.y > 1)
-				tclearregion(0, 0, term.col-1, term.c.y-1);
-			tclearregion(0, term.c.y, term.c.x, term.c.y);
+			if (term.c.y >= 1)
+				tclearregion(0, 0, term.col-1, term.c.y-1, 1);
+			tclearregion(0, term.c.y, term.c.x, term.c.y, 1);
 			break;
-		case 2: /* all */
-			tclearregion(0, 0, term.col-1, term.row-1);
+        case 2: /* all */
+            if (IS_SET(MODE_ALTSCREEN)) {
+                tclearregion(0, 0, term.col-1, term.row-1, 1);
+                break;
+            }
+            /* vte does this:
+               tscrollup(0, term.row-1, term.row, SCROLL_SAVEHIST); */
+
+            /* alacritty does this: */
+            for (n = term.row-1; n >= 0 && tlinelen(term.line[n]) == 0; n--);
+            if (n >= 0)
+                tscrollup(0, term.row-1, n+1, SCROLL_SAVEHIST);
+            tscrollup(0, term.row-1, term.row-n-1, SCROLL_NOSAVEHIST);
 			break;
 		default:
 			goto unknown;
